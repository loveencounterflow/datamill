// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var $, $async, $watch, CND, PATH, PD, VNR, XXX_COLORIZER, _color_cache, assign, badge, cast, debug, declare, echo, help, info, isa, jr, rpr, select, size_of, stamp, to_width, type_of, types, urge, validate, warn, whisper, width_of;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'DATAMILL/HELPERS';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  ({jr, assign} = CND);

  //...........................................................................................................
  PATH = require('path');

  VNR = require('./vnr');

  ({to_width, width_of} = require('to-width'));

  //...........................................................................................................
  PD = require('pipedreams');

  ({$, $watch, $async, select, stamp} = PD);

  //...........................................................................................................
  types = require('./types');

  ({isa, validate, cast, declare, size_of, type_of} = types);

  XXX_COLORIZER = require('./experiments/colorizer');

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.cwd_abspath = CND.cwd_abspath;

  this.cwd_relpath = CND.cwd_relpath;

  this.here_abspath = CND.here_abspath;

  this._drop_extension = (path) => {
    return path.slice(0, path.length - (PATH.extname(path)).length);
  };

  this.project_abspath = (...P) => {
    return CND.here_abspath(__dirname, '..', ...P);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.badge_from_filename = function(filename) {
    var basename;
    basename = PATH.basename(filename);
    return 'DATAMILL/' + (basename.replace(/^(.*?)\.[^.]+$/, '$1')).toUpperCase();
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.format_object = (d) => {
    var R, i, k, len, ref1;
    R = {};
    ref1 = ((function() {
      var results;
      results = [];
      for (k in d) {
        results.push(k);
      }
      return results;
    })()).sort();
    for (i = 0, len = ref1.length; i < len; i++) {
      k = ref1[i];
      R[k] = d[k];
    }
    return jr(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_datom = (...P) => {
    var R;
    R = PD.new_datom(...P);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fresh_datom = (...P) => {
    var R;
    R = PD.new_datom(...P);
    R = PD.set(R, '$fresh', true);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.swap_key = function(d, key, $vnr = null) {
    var R;
    /* Given a datom `d`, compute the first `$vnr` for the next level (or use the optional `$vnr` argument)
    and set the `key` on a copy. Make sure `$fresh` is set and `$dirty` is unset.
    */
    if ($vnr == null) {
      $vnr = VNR.new_level(d.$vnr, 1);
    }
    R = d;
    R = PD.set(R, 'key', key);
    R = PD.set(R, '$vnr', $vnr);
    R = PD.set(R, '$fresh', true);
    R = PD.unset(R, '$dirty');
    return R;
  };

  //===========================================================================================================
  // DB QUERIES
  //-----------------------------------------------------------------------------------------------------------
  this.row_from_vnr = (S, vnr) => {
    var dbr;
    validate.vnr(vnr);
    dbr = S.mirage.dbr;
    vnr = JSON.stringify(vnr);
    return dbr.$.first_row(dbr.datom_from_vnr({vnr}));
  };

  //-----------------------------------------------------------------------------------------------------------
  this.datom_from_vnr = (S, vnr) => {
    var row;
    if ((row = this.row_from_vnr(S, vnr)) == null) {
      return null;
    }
    return this.datom_from_row(S, row);
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.register_new_key = (S, key, settings) => {
    var db, error, has_paragraphs, is_block, ref1, ref2;
    validate.datamill_register_key_settings;
    db = S.mirage.dbw;
    is_block = cast.boolean('number', (ref1 = settings.is_block) != null ? ref1 : false);
    has_paragraphs = cast.boolean('number', (ref2 = settings.has_paragraphs) != null ? ref2 : false);
    try {
      db.register_key({key, is_block, has_paragraphs});
    } catch (error1) {
      error = error1;
      if (!error.message.startsWith("UNIQUE constraint failed")) {
        throw error;
      }
      // throw new Error "µ77754 key #{rpr key} already registered"
      warn(`µ77754 key ${rpr(key)} already registered`);
    }
    this._key_registry_cache = null;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.register_key = (S, key, settings) => {
    var db, definition, entry, has_paragraphs, is_block, ref1, ref2, ref3, ref4;
    /* TAINT code duplication */
    validate.datamill_register_key_settings;
    db = S.mirage.dbw;
    is_block = (ref1 = settings.is_block) != null ? ref1 : false;
    has_paragraphs = (ref2 = settings.has_paragraphs) != null ? ref2 : false;
    if ((entry = db.$.first_row(db.get_key_entry({key}))) == null) {
      return this.register_new_key(S, key, settings);
    }
    definition = {key, is_block, has_paragraphs};
    entry.is_block = cast.number('boolean', (ref3 = entry.is_block) != null ? ref3 : 0);
    entry.has_paragraphs = cast.number('boolean', (ref4 = entry.has_paragraphs) != null ? ref4 : 0);
    if (!CND.equals(definition, entry)) {
      throw new Error(`µ87332 given key definition ${jr(definition)} doesn't match esisting entry ${rpr(entry)}`);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._key_registry_cache = null;

  //-----------------------------------------------------------------------------------------------------------
  this.get_key_registry = (S) => {
    var R, db, ref1, row;
    if (this._key_registry_cache != null) {
      return this._key_registry_cache;
    }
    db = S.mirage.dbw;
    R = {};
    ref1 = db.read_key_registry();
    for (row of ref1) {
      R[row.key] = row;
    }
    this._key_registry_cache = PD.freeze(R);
    return R;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.datom_from_row = (S, row) => {
    var $vnr, R, k, p, ref1, vnr;
    vnr = row.vnr;
    $vnr = JSON.parse(vnr);
    p = row.p != null ? JSON.parse(row.p) : {};
    R = PD.thaw(PD.new_datom(row.key, {$vnr}));
    R.dest = row.dest;
    R.ref = row.ref;
    if (row.text != null) {
      R.text = row.text;
    }
    if ((ref1 = row.stamped) != null ? ref1 : false) {
      R.$stamped = true;
    }
    for (k in p) {
      if (p[k] != null) {
        R[k] = p[k];
      }
    }
    return PD.freeze(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.p_from_datom = (S, d) => {
    var R, count, k, v;
    R = {};
    count = 0;
    for (k in d) {
      v = d[k];
      if (k === 'key') {
        continue;
      }
      if (k === 'text') {
        continue;
      }
      if (k === 'dest') {
        continue;
      }
      if (k === 'ref') {
        continue;
      }
      if (k.startsWith('$')) {
        continue;
      }
      if (v == null) {
        continue;
      }
      count += 1;
      R[k] = v;
    }
    if (count === 0) {
      R = null;
    }
    return JSON.stringify(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.row_from_datom = (S, d) => {
    var R, dest, key, p, ref, ref1, ref2, ref3, ref4, stamped, text, vnr;
    key = d.key;
    vnr = d.$vnr;
    stamped = (ref1 = d.$stamped) != null ? ref1 : false;
    dest = (ref2 = d.dest) != null ? ref2 : S.mirage.default_dest;
    text = (ref3 = d.text) != null ? ref3 : null;
    ref = (ref4 = d.ref) != null ? ref4 : null;
    p = this.p_from_datom(S, d);
    R = {key, vnr, dest, text, p, stamped, ref};
    // R         = { key, vnr, vnr_blob, dest, text, p, stamped, }
    // MIRAGE.types.validate.mirage_main_row R if do_validate
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.feed_source = (S, source, limit = 2e308) => {
    /* TAINT do casting in DB module */
    var dbr, nr, row, rows, start_vnr, start_vnr_blob, stop_vnr, stop_vnr_blob;
    validate.datamill_S_confine(S.confine_to);
    dbr = S.mirage.db;
    nr = 0;
    //.........................................................................................................
    if (S.confine_to != null) {
      ({start_vnr, stop_vnr} = S.confine_to);
      start_vnr_blob = dbr.$.as_hollerith(start_vnr);
      stop_vnr_blob = dbr.$.as_hollerith(stop_vnr);
      rows = dbr.read_unstamped_lines({start_vnr_blob, stop_vnr_blob});
    } else {
      //.........................................................................................................
      rows = dbr.read_unstamped_lines();
    }
//.........................................................................................................
    for (row of rows) {
      nr += +1;
      if (nr > limit) {
        break;
      }
      source.send(this.datom_from_row(S, row));
    }
    //.........................................................................................................
    source.end();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$feed_db = (S) => {
    var dbw;
    dbw = S.mirage.dbw;
    return $watch((d) => {
      /* NOTE force insert when update was without effect; this happens when `$vnr` was
      affected by a `PD.set()` call (ex. `VNR.advance $vnr; send PD.set d, '$vnr', $vnr`). */
      /* TAINT how to convert vnr in ICQL? */
      var changes, error, methods, row;
      row = this.row_from_datom(S, d);
      methods = [];
      try {
        /* TAINT consider to use upsert instead https://www.sqlite.org/lang_UPSERT.html */
        /* NOTE Make sure to test first for `$fresh`/inserts, then for `$dirty`/updates, since a `$fresh`
        datom may have undergone changes (which doesn't make the correct opertion an update). */
        if (d.$fresh) {
          methods.push('insert fresh');
          dbw.insert(row);
        } else if (d.$dirty) {
          ({changes} = dbw.update(row));
          if (changes === 0) {
            methods.push('insert dirty');
            dbw.insert(row);
          }
        }
      } catch (error1) {
        error = error1;
        warn('µ12133', `when trying to ${methods.join(' -> ')} row`);
        warn('µ12133', jr(row));
        warn('µ12133', "an error occurred:");
        warn('µ12133', `${error.message}`);
        if (error.message.startsWith('UNIQUE constraint failed')) {
          urge('µ88768', "conflict occurred because");
          urge('µ88768', jr(this.row_from_vnr(S, d.$vnr)));
          urge('µ88768', "is already in DB");
        }
        throw error;
      }
      return null;
    });
  };

  //===========================================================================================================
  // PHASES
  //-----------------------------------------------------------------------------------------------------------
  this.repeat_phase = (S, phase) => {
    validate.datamill_phase_repeat(phase.repeat_phase);
    if (phase.repeat_phase == null) {
      return false;
    }
    if (isa.boolean(phase.repeat_phase)) {
      return phase.repeat_phase;
    }
    return phase.repeat_phase(S);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.break_phase_and_repeat_confined_to = (S, confine_to) => {
    validate.datamill_S_confine(confine_to);
    S.control.push(PD.new_datom('~break_phase_and_repeat_confined_to', confine_to));
    return null;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.$show = (S) => {
    return $watch((d) => {
      var color;
      if (d.$stamped) {
        color = CND.grey;
      } else {
        switch (d.key) {
          case '^word':
            color = CND.gold;
            break;
          default:
            color = CND.white;
        }
      }
      return info(color(jr(d)));
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_tty_width = (S) => {
    var R, execSync;
    if ((R = process.stdout.columns) != null) {
      return R;
    }
    ({execSync} = require('child_process'));
    return parseInt(execSync("tput cols", {
      encoding: 'utf-8'
    }), 10);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.show_overview = (S, settings) => {
    /* TAINT consider to convert row to datom before display */
    var _color, color, combi, dbr, defaults, dent, dest, key, level, line, line_width, omit_count, p, ref, ref1, ref2, ref3, ref4, row, skip_blanks, skip_stamped, text, value, vnr, xxxxx;
    line_width = this.get_tty_width(S);
    dbr = S.mirage.db;
    level = 0;
    omit_count = 0;
    skip_stamped = false;
    skip_blanks = false;
    //.........................................................................................................
    defaults = {
      raw: false,
      hilite: null
    };
    settings = assign({}, defaults, settings);
    ref1 = dbr.read_lines();
    // { limit: 30, }
    //.........................................................................................................
    for (row of ref1) {
      if (settings.raw) {
        info(this.format_object(row));
        continue;
      }
      if ((row.key === '^line') && row.stamped && (row.text === '')) {
        omit_count += +1;
        continue;
      }
      if (skip_blanks && (row.key === '^blank')) {
        omit_count += +1;
        continue;
      }
      if (skip_stamped && row.stamped) {
        omit_count += +1;
        continue;
      }
      switch (row.key) {
        case '^line':
          _color = CND.YELLOW;
          break;
        case '^block':
          _color = CND.gold;
          break;
        case '^mktscript':
          _color = CND.ORANGE;
          break;
        case '~warning':
          _color = CND.RED;
          break;
        case '~notice':
          _color = CND.cyan;
          break;
        case '^literal':
          _color = CND.GREEN;
          break;
        case '^literal-blank':
          _color = CND.GREEN;
          break;
        case '^p':
          _color = CND.BLUE;
          break;
        case '<h':
          _color = CND.VIOLET;
          break;
        case '>h':
          _color = CND.VIOLET;
          break;
        default:
          _color = this.color_from_text(row.key.slice(1));
      }
      //.......................................................................................................
      stamp = row.stamped ? '*' : '';
      key = to_width(row.key, 15);
      vnr = to_width(stamp + row.vnr, 12);
      dest = to_width(row.dest, 4);
      ref = to_width((ref2 = row.ref) != null ? ref2 : '', 9);
      text = row.text != null ? jr(row.text) : null;
      p = (ref3 = row.p) != null ? ref3 : null;
      if (p === 'null') {
        p = null;
      }
      //.......................................................................................................
      combi = [];
      if (text != null) {
        combi.push(text);
      }
      if (p != null) {
        combi.push(p);
      }
      value = combi.join(' / ');
      // value   = value[ .. 80 ]
      line = `${vnr}│${dest}│${ref}│${key}│${value}`;
      line = to_width(line, line_width);
      dent = '  '.repeat(level);
      level = (function() {
        switch (row.key[0]) {
          case '<':
            return level + 1;
          case '>':
            return level - 1;
          default:
            return level;
        }
      })();
      level = Math.max(level, 0);
      //.......................................................................................................
      if ((settings.hilite != null) && (settings.hilite === row.key)) {
        color = function(...P) {
          return CND.reverse(CND.pink(...P));
        };
      } else if (row.stamped || row.key === '^blank') {
        color = CND.grey;
      } else {
        color = function(...P) {
          return CND.reverse(_color(...P));
        };
      }
      //.......................................................................................................
      /* TAINT experimental, needs better implementation */
      xxxxx = 44;
      if (row.stamped) {
        echo((color(line.slice(0, xxxxx))) + CND.grey(line.slice(xxxxx)));
      } else if (line[xxxxx] === '"') {
        echo((color(line.slice(0, xxxxx))) + CND.reverse(CND.YELLOW(line.slice(xxxxx))));
      } else {
        echo((color(line.slice(0, xxxxx))) + CND.RED(line.slice(xxxxx)));
      }
    }
    // echo dent + color line
    //.........................................................................................................
    echo(`${omit_count} rows omitted from this view`);
    ref4 = dbr.get_stats();
    for (row of ref4) {
      echo(`${row.key}: ${row.count}`);
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  _color_cache = {};

  this.color_from_text = function(text) {
    var R;
    if ((R = _color_cache[text]) != null) {
      return R;
    }
    R = function(...P) {
      return (XXX_COLORIZER.ansi_code_from_text(text)) + CND._pen(...P);
    };
    // R = ( P... ) -> CND.reverse ( XXX_COLORIZER.ansi_code_from_text text ) + CND._pen P...
    _color_cache[text] = R;
    return R;
  };

}).call(this);

//# sourceMappingURL=helpers.js.map
