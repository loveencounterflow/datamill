// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var $, $async, $watch, CND, PATH, PD, VNR, XXX_COLORIZER, _color_cache, assign, badge, debug, declare, echo, help, info, isa, jr, rpr, select, size_of, stamp, to_width, type_of, types, urge, validate, warn, whisper, width_of;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'DATAMILL/HELPERS';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  ({jr, assign} = CND);

  //...........................................................................................................
  PATH = require('path');

  VNR = require('./vnr');

  ({to_width, width_of} = require('to-width'));

  //...........................................................................................................
  PD = require('pipedreams');

  ({$, $watch, $async, select, stamp} = PD);

  //...........................................................................................................
  types = require('./types');

  ({isa, validate, declare, size_of, type_of} = types);

  XXX_COLORIZER = require('./experiments/colorizer');

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.cwd_abspath = CND.cwd_abspath;

  this.cwd_relpath = CND.cwd_relpath;

  this.here_abspath = CND.here_abspath;

  this._drop_extension = (path) => {
    return path.slice(0, path.length - (PATH.extname(path)).length);
  };

  this.project_abspath = (...P) => {
    return CND.here_abspath(__dirname, '..', ...P);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.badge_from_filename = function(filename) {
    var basename;
    basename = PATH.basename(filename);
    return 'DATAMILL/' + (basename.replace(/^(.*?)\.[^.]+$/, '$1')).toUpperCase();
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.format_object = (d) => {
    var R, i, k, len, ref;
    R = {};
    ref = ((function() {
      var results;
      results = [];
      for (k in d) {
        results.push(k);
      }
      return results;
    })()).sort();
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      R[k] = d[k];
    }
    return jr(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_datom = (...P) => {
    var R;
    R = PD.new_datom(...P);
    // R = PD.set R, 'vnr_txt',  ( jr R.$vnr ) if R.$vnr?
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fresh_datom = (...P) => {
    var R;
    R = PD.new_datom(...P);
    // R = PD.set R, 'vnr_txt',  ( jr R.$vnr ) if R.$vnr?
    R = PD.set(R, '$fresh', true);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.swap_key = function(d, key, $vnr = null) {
    var R;
    /* Given a datom `d`, compute the first `$vnr` for the next level (or use the optional `$vnr` argument)
    and set the `key` on a copy. Make sure `$fresh` is set and `$dirty` is unset.
    */
    if ($vnr == null) {
      $vnr = VNR.new_level(d.$vnr, 1);
    }
    R = d;
    R = PD.set(R, 'key', key);
    R = PD.set(R, '$vnr', $vnr);
    R = PD.set(R, '$fresh', true);
    R = PD.unset(R, '$dirty');
    return R;
  };

  //===========================================================================================================
  // DB QUERIES
  //-----------------------------------------------------------------------------------------------------------
  this.previous_line_is_blank = (S, vnr) => {
    var d;
    if ((d = this.get_previous_datom(S, vnr)) == null) {
      return true;
    }
    return ((d.text != null) && d.text.match(/^\s*$/)) != null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.next_line_is_blank = (S, vnr) => {
    var d;
    if ((d = this.get_next_datom(S, vnr)) == null) {
      return true;
    }
    return ((d.text != null) && d.text.match(/^\s*$/)) != null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_previous_datom = (S, vnr) => {
    var vnr_txt;
    /* TAINT consider to use types */
    if (vnr.length !== 1) {
      throw new Error(`µ33442 \`get_next_datom()\` not supported for nested vnrs, got ${rpr(vnr)}`);
    }
    if (!(vnr[0] > 1)) {
      /* TAINT need inverse to advance */
      return null;
    }
    vnr_txt = jr([vnr[0] - 1]);
    return this.datom_from_vnr(S, vnr);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_next_datom = (S, vnr) => {
    /* TAINT consider to use types */
    if (vnr.length !== 1) {
      throw new Error(`µ33442 \`get_next_datom()\` not supported for nested vnrs, got ${rpr(vnr)}`);
    }
    return this.datom_from_vnr(S, VNR.advance(vnr));
  };

  //-----------------------------------------------------------------------------------------------------------
  this.row_from_vnr = (S, vnr) => {
    var dbr, vnr_txt;
    dbr = S.mirage.dbr;
    vnr_txt = jr(vnr);
    return dbr.$.first_row(dbr.datom_from_vnr({vnr_txt}));
  };

  //-----------------------------------------------------------------------------------------------------------
  this.datom_from_vnr = (S, vnr) => {
    var row;
    if ((row = this.row_from_vnr(S, vnr)) == null) {
      return null;
    }
    return this.datom_from_row(S, row);
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.datom_from_row = (S, row) => {
    var $vnr, R, k, p, ref, vnr_txt;
    /* TAINT how to convert vnr in ICQL? */
    // debug 'µ22373', rpr row
    // debug 'µ22373', rpr row.vnr_txt
    // debug 'µ22373', rpr row.p
    vnr_txt = row.vnr_txt;
    $vnr = JSON.parse(vnr_txt);
    p = row.p != null ? JSON.parse(row.p) : {};
    R = PD.thaw(PD.new_datom(row.key, {$vnr}));
    R.region = row.region;
    if (row.text != null) {
      R.text = row.text;
    }
    if ((ref = row.stamped) != null ? ref : false) {
      R.$stamped = true;
    }
    for (k in p) {
      if (p[k] != null) {
        R[k] = p[k];
      }
    }
    return PD.freeze(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.p_from_datom = (S, d) => {
    var R, count, k, v;
    R = {};
    count = 0;
    for (k in d) {
      v = d[k];
      if (k === 'key') {
        continue;
      }
      if (k === 'text') {
        continue;
      }
      if (k === 'region') {
        continue;
      }
      if (k.startsWith('$')) {
        continue;
      }
      if (v == null) {
        continue;
      }
      count += 1;
      R[k] = v;
    }
    if (count === 0) {
      R = null;
    }
    return JSON.stringify(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.row_from_datom = (S, d) => {
    /* TAINT how to convert booleans in ICQL? */
    var R, key, p, ref, ref1, region, stamped, text, vnr_txt;
    key = d.key;
    stamped = (PD.is_stamped(d)) ? 1 : 0;
    vnr_txt = JSON.stringify(d.$vnr);
    region = (ref = d.region) != null ? ref : null;
    text = (ref1 = d.text) != null ? ref1 : null;
    p = this.p_from_datom(S, d);
    R = {key, vnr_txt, region, text, p, stamped};
    // MIRAGE.types.validate.mirage_main_row R if do_validate
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.feed_source = (S, source, limit = 2e308) => {
    var dbr, nr, ref, row;
    dbr = S.mirage.db;
    nr = 0;
    ref = dbr.read_unstamped_lines();
    //.........................................................................................................
    for (row of ref) {
      nr += +1;
      if (nr > limit) {
        break;
      }
      source.send(this.datom_from_row(S, row));
    }
    //.........................................................................................................
    source.end();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$feed_db = (S) => {
    var dbw;
    dbw = S.mirage.dbw;
    return $watch((d) => {
      /* TAINT how to convert vnr in ICQL? */
      var error, row;
      row = this.row_from_datom(S, d);
      try {
        /* TAINT consider to use upsert instead https://www.sqlite.org/lang_UPSERT.html */
        /* NOTE Make sure to test first for `$fresh`/inserts, then for `$dirty`/updates, since a `$fresh`
        datom may have undergone changes (which doesn't make the correct opertion an update). */
        if (d.$fresh) {
          dbw.insert(row);
        } else if (d.$dirty) {
          dbw.update(row);
        }
      } catch (error1) {
        error = error1;
        warn('µ12133', "when trying to insert or update row");
        warn('µ12133', jr(row));
        warn('µ12133', "an error occurred:");
        warn('µ12133', `${error.message}`);
        if (error.message.startsWith('UNIQUE constraint failed')) {
          urge('µ88768', "conflict occurred because");
          urge('µ88768', jr(this.row_from_vnr(S, d.$vnr)));
          urge('µ88768', "is already in DB");
        }
        throw error;
      }
      return null;
    });
  };

  //===========================================================================================================
  // PHASES
  //-----------------------------------------------------------------------------------------------------------
  this.repeat_phase = (S, phase) => {
    validate.datamill_phase_repeat(phase.repeat_phase);
    if (phase.repeat_phase == null) {
      return false;
    }
    if (isa.boolean(phase.repeat_phase)) {
      return phase.repeat_phase;
    }
    return phase.repeat_phase(S);
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.$show = (S) => {
    return $watch((d) => {
      var color;
      if (d.$stamped) {
        color = CND.grey;
      } else {
        switch (d.key) {
          case '^word':
            color = CND.gold;
            break;
          default:
            color = CND.white;
        }
      }
      return info(color(jr(d)));
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_tty_width = (S) => {
    var R, execSync;
    if ((R = process.stdout.columns) != null) {
      return R;
    }
    ({execSync} = require('child_process'));
    return parseInt(execSync("tput cols", {
      encoding: 'utf-8'
    }), 10);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.show_overview = (S, raw = false) => {
    /* TAINT consider to convert row to datom before display */
    var _color, color, dbr, dent, key, level, line, line_width, omit_count, p, ref, ref1, region, row, text, value, vnr;
    line_width = this.get_tty_width(S);
    dbr = S.mirage.db;
    level = 0;
    omit_count = 0;
    ref = dbr.read_lines();
    // { limit: 30, }
    //.........................................................................................................
    for (row of ref) {
      if (raw) {
        info(this.format_object(row));
        continue;
      }
      if ((row.key === '^line') && row.stamped && (row.text === '')) {
        omit_count += +1;
        continue;
      }
      switch (row.key) {
        case '^line':
          _color = CND.YELLOW;
          break;
        case '^block':
          _color = CND.gold;
          break;
        case '^mktscript':
          _color = CND.RED;
          break;
        case '~warning':
          _color = CND.RED;
          break;
        case '~notice':
          _color = CND.cyan;
          break;
        case '^literal':
          _color = CND.GREEN;
          break;
        case '^p':
          _color = CND.BLUE;
          break;
        case '<h':
          _color = CND.VIOLET;
          break;
        case '>h':
          _color = CND.VIOLET;
          break;
        default:
          _color = this.color_from_text(row.key.slice(1));
      }
      //.......................................................................................................
      if (row.key === '^blank') {
        key = to_width('', 12);
        vnr = to_width('', 12);
        region = to_width('', 8);
        text = '';
        p = '';
      } else {
        //.......................................................................................................
        key = to_width(row.key, 12);
        vnr = to_width(row.vnr_txt, 12);
        region = to_width(row.region, 8);
        text = row.text != null ? jr(row.text) : '';
        p = row.p != null ? row.p : '';
        if ((p == null) || (p === 'null')) {
          p = '';
        }
      }
      //.......................................................................................................
      value = text + ' ' + p;
      // value   = value[ .. 80 ]
      stamp = row.stamped ? 'S' : ' ';
      line = `${vnr} │ ${region} │ ${stamp} │ ${key} │ ${value}`;
      line = to_width(line, line_width);
      dent = '  '.repeat(level);
      level = (function() {
        switch (row.key[0]) {
          case '<':
            return level + 1;
          case '>':
            return level - 1;
          default:
            return level;
        }
      })();
      level = Math.max(level, 0);
      color = (row.stamped || row.key === '^blank') ? CND.grey : function(...P) {
        return CND.reverse(_color(...P));
      };
      // color = if row.stamped then _color else ( P... ) -> CND.reverse _color P...
      echo(color(line));
    }
    // echo dent + color line
    //.........................................................................................................
    echo(`${omit_count} rows omitted from this view`);
    ref1 = dbr.get_stats();
    for (row of ref1) {
      echo(`${row.key}: ${row.count}`);
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  _color_cache = {};

  this.color_from_text = function(text) {
    var R;
    if ((R = _color_cache[text]) != null) {
      return R;
    }
    R = function(...P) {
      return (XXX_COLORIZER.ansi_code_from_text(text)) + CND._pen(...P);
    };
    // R = ( P... ) -> CND.reverse ( XXX_COLORIZER.ansi_code_from_text text ) + CND._pen P...
    _color_cache[text] = R;
    return R;
  };

}).call(this);

//# sourceMappingURL=helpers.js.map
