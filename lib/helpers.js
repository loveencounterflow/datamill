// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var $, $async, $watch, CND, PATH, PD, VNR, assign, badge, debug, declare, echo, help, info, isa, jr, rpr, select, size_of, stamp, to_width, type_of, types, urge, validate, warn, whisper, width_of;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'DATAMILL/HELPERS';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  ({jr, assign} = CND);

  //...........................................................................................................
  PATH = require('path');

  VNR = require('./vnr');

  ({to_width, width_of} = require('to-width'));

  //...........................................................................................................
  PD = require('pipedreams');

  ({$, $watch, $async, select, stamp} = PD);

  //...........................................................................................................
  types = require('./types');

  ({isa, validate, declare, size_of, type_of} = types);

  //...........................................................................................................
  this.cwd_abspath = CND.cwd_abspath;

  this.cwd_relpath = CND.cwd_relpath;

  this.here_abspath = CND.here_abspath;

  this._drop_extension = (path) => {
    return path.slice(0, path.length - (PATH.extname(path)).length);
  };

  this.project_abspath = (...P) => {
    return CND.here_abspath(__dirname, '..', ...P);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.format_object = (d) => {
    var R, i, k, len, ref;
    R = {};
    ref = ((function() {
      var results;
      results = [];
      for (k in d) {
        results.push(k);
      }
      return results;
    })()).sort();
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      R[k] = d[k];
    }
    return jr(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_datom = (...P) => {
    var R;
    R = PD.new_datom(...P);
    // R = PD.set R, 'vnr_txt',  ( jr R.$vnr ) if R.$vnr?
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fresh_datom = (...P) => {
    var R;
    R = PD.new_datom(...P);
    // R = PD.set R, 'vnr_txt',  ( jr R.$vnr ) if R.$vnr?
    R = PD.set(R, '$fresh', true);
    return R;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.$show = (S) => {
    return $watch((d) => {
      var color;
      if (d.$stamped) {
        color = CND.grey;
      } else {
        switch (d.key) {
          case '^word':
            color = CND.gold;
            break;
          default:
            color = CND.white;
        }
      }
      return info(color(jr(d)));
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.show_overview = (S) => {
    var _color, color, dbr, dent, key, level, line, ref, ref1, row, value, vnr;
    dbr = S.mirage.db;
    level = 0;
    ref = dbr.read_lines();
    // { limit: 30, }
    //.........................................................................................................
    for (row of ref) {
      // debug 'µ10001', rpr row
      if ((row.key === '^mktscript') && (row.value === '')) {
        continue;
      }
      if (row.key === '^blank') {
        echo(CND.white('-'.repeat(100)));
        continue;
      }
      switch (row.key) {
        case '^mktscript':
          _color = CND.YELLOW;
          break;
        case '^blank':
          _color = CND.grey;
          break;
        case '~warning':
          _color = CND.RED;
          break;
        case '^literal':
          _color = CND.GREEN;
          break;
        case '<h':
          _color = CND.VIOLET;
          break;
        case '>h':
          _color = CND.VIOLET;
          break;
        default:
          _color = CND.white;
      }
      key = row.key.padEnd(12);
      vnr = row.vnr_txt.padEnd(12);
      value = (isa.text(row.value)) ? row.value : rpr(row.value);
      value = value.slice(0, 81);
      stamp = row.stamped ? 'S' : ' ';
      line = `${vnr} ${stamp} ${key} ${rpr(value)}`;
      line = to_width(line, 100);
      dent = '  '.repeat(level);
      level = (function() {
        switch (row.key[0]) {
          case '<':
            return level + 1;
          case '>':
            return level - 1;
          default:
            return level;
        }
      })();
      color = row.stamped ? CND.grey : function(...P) {
        return CND.reverse(_color(...P));
      };
      // color = if row.stamped then _color else ( P... ) -> CND.reverse _color P...
      echo(dent + color(line));
    }
    ref1 = dbr.get_stats();
    //.........................................................................................................
    for (row of ref1) {
      echo(`${row.key}: ${row.count}`);
    }
    //.........................................................................................................
    return null;
  };

  //===========================================================================================================
  // DB QUERIES
  //-----------------------------------------------------------------------------------------------------------
  this.previous_line_is_blank = (S, vnr) => {
    var d;
    if ((d = this.get_previous_datom(S, vnr)) == null) {
      return true;
    }
    return (d.value.match(/^\s*$/)) != null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.next_line_is_blank = (S, vnr) => {
    var d;
    if ((d = this.get_next_datom(S, vnr)) == null) {
      return true;
    }
    return (d.value.match(/^\s*$/)) != null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_previous_datom = (S, vnr) => {
    var vnr_txt;
    /* TAINT consider to use types */
    if (vnr.length !== 1) {
      throw new Error(`µ33442 \`get_next_datom()\` not supported for nested vnrs, got ${rpr(vnr)}`);
    }
    if (!(vnr[0] > 1)) {
      /* TAINT need inverse to advance */
      return null;
    }
    vnr_txt = jr([vnr[0] - 1]);
    return this.datom_from_vnr(S, S, vnr);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_next_datom = (S, vnr) => {
    /* TAINT consider to use types */
    if (vnr.length !== 1) {
      throw new Error(`µ33442 \`get_next_datom()\` not supported for nested vnrs, got ${rpr(vnr)}`);
    }
    return this.datom_from_vnr(S, VNR.advance(vnr));
  };

  //-----------------------------------------------------------------------------------------------------------
  this.datom_from_vnr = (S, vnr) => {
    var dbr, row, vnr_txt;
    dbr = S.mirage.dbr;
    vnr_txt = jr(vnr);
    if ((row = dbr.$.first_row(dbr.datom_from_vnr({vnr_txt}))) == null) {
      return null;
    }
    return this.datom_from_row(S, row);
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.datom_from_row = (S, row) => {
    /* TAINT how to convert vnr in ICQL? */
    var $vnr, R, vnr_txt;
    vnr_txt = row.vnr_txt;
    $vnr = JSON.parse(vnr_txt);
    R = PD.new_datom(row.key, {
      value: row.value,
      $vnr
    });
    if (row.stamped) {
      R = PD.set(R, '$stamped', true);
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.row_from_datom = (S, d) => {
    /* TAINT how to convert booleans in ICQL? */
    var R, stamped, value, vnr_txt;
    stamped = (PD.is_stamped(d)) ? 1 : 0;
    vnr_txt = jr(d.$vnr);
    value = (isa.text(d.value)) ? d.value : jr(d.value);
    R = {
      key: d.key,
      vnr_txt,
      value,
      stamped
    };
    // MIRAGE.types.validate.mirage_main_row R if do_validate
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.feed_source = (S, source, limit = 2e308) => {
    var dbr, nr, ref, row;
    dbr = S.mirage.db;
    nr = 0;
    ref = dbr.read_unstamped_lines();
    //.........................................................................................................
    for (row of ref) {
      nr += +1;
      if (nr > limit) {
        break;
      }
      source.send(this.datom_from_row(S, row));
    }
    //.........................................................................................................
    source.end();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$feed_db = (S) => {
    var dbw;
    dbw = S.mirage.dbw;
    return $watch((d) => {
      /* TAINT how to convert vnr in ICQL? */
      var error, row;
      row = this.row_from_datom(S, d);
      try {
        /* TAINT consider to use upsert instead https://www.sqlite.org/lang_UPSERT.html */
        if (d.$fresh) {
          dbw.insert(row);
        } else if (d.$dirty) {
          dbw.update(row);
        }
      } catch (error1) {
        error = error1;
        warn(`µ12133 when trying to insert or update row ${jr(row)}`);
        warn("µ12133 an error occurred:");
        warn(`µ12133 ${error.message}`);
        throw error;
      }
      return null;
    });
  };

}).call(this);

//# sourceMappingURL=helpers.js.map
