// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var $, $async, $watch, CND, PATH, PD, VNR, XXX_COLORIZER, _color_cache, assign, badge, debug, declare, echo, help, info, isa, jr, rpr, select, size_of, stamp, to_width, type_of, types, urge, validate, warn, whisper, width_of;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'DATAMILL/HELPERS';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  ({jr, assign} = CND);

  //...........................................................................................................
  PATH = require('path');

  VNR = require('./vnr');

  ({to_width, width_of} = require('to-width'));

  //...........................................................................................................
  PD = require('pipedreams');

  ({$, $watch, $async, select, stamp} = PD);

  //...........................................................................................................
  types = require('./types');

  ({isa, validate, declare, size_of, type_of} = types);

  XXX_COLORIZER = require('./experiments/colorizer');

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.cwd_abspath = CND.cwd_abspath;

  this.cwd_relpath = CND.cwd_relpath;

  this.here_abspath = CND.here_abspath;

  this._drop_extension = (path) => {
    return path.slice(0, path.length - (PATH.extname(path)).length);
  };

  this.project_abspath = (...P) => {
    return CND.here_abspath(__dirname, '..', ...P);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.badge_from_filename = function(filename) {
    var basename;
    basename = PATH.basename(filename);
    return 'DATAMILL/' + (basename.replace(/^(.*?)\.[^.]+$/, '$1')).toUpperCase();
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.format_object = (d) => {
    var R, i, k, len, ref;
    R = {};
    ref = ((function() {
      var results;
      results = [];
      for (k in d) {
        results.push(k);
      }
      return results;
    })()).sort();
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      R[k] = d[k];
    }
    return jr(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_datom = (...P) => {
    var R;
    R = PD.new_datom(...P);
    // R = PD.set R, 'vnr_txt',  ( jr R.$vnr ) if R.$vnr?
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fresh_datom = (...P) => {
    var R;
    R = PD.new_datom(...P);
    // R = PD.set R, 'vnr_txt',  ( jr R.$vnr ) if R.$vnr?
    R = PD.set(R, '$fresh', true);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.swap_key = function(d, key, $vnr = null) {
    var R;
    /* Given a datom `d`, compute the first `$vnr` for the next level (or use the optional `$vnr` argument)
    and set the `key` on a copy. Make sure `$fresh` is set and `$dirty` is unset.
    */
    if ($vnr == null) {
      $vnr = VNR.new_level(d.$vnr, 1);
    }
    R = d;
    R = PD.set(R, 'key', key);
    R = PD.set(R, '$vnr', $vnr);
    R = PD.set(R, '$fresh', true);
    R = PD.unset(R, '$dirty');
    return R;
  };

  //===========================================================================================================
  // DB QUERIES
  //-----------------------------------------------------------------------------------------------------------
  this.previous_line_is_blank = (S, vnr) => {
    var d;
    if ((d = this.get_previous_datom(S, vnr)) == null) {
      return true;
    }
    return ((d.text != null) && d.text.match(/^\s*$/)) != null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.next_line_is_blank = (S, vnr) => {
    var d;
    if ((d = this.get_next_datom(S, vnr)) == null) {
      return true;
    }
    return ((d.text != null) && d.text.match(/^\s*$/)) != null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_previous_datom = (S, vnr) => {
    var vnr_txt;
    /* TAINT consider to use types */
    if (vnr.length !== 1) {
      throw new Error(`µ33442 \`get_next_datom()\` not supported for nested vnrs, got ${rpr(vnr)}`);
    }
    if (!(vnr[0] > 1)) {
      /* TAINT need inverse to advance */
      return null;
    }
    vnr_txt = jr([vnr[0] - 1]);
    return this.datom_from_vnr(S, vnr);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_next_datom = (S, vnr) => {
    /* TAINT consider to use types */
    if (vnr.length !== 1) {
      throw new Error(`µ33442 \`get_next_datom()\` not supported for nested vnrs, got ${rpr(vnr)}`);
    }
    return this.datom_from_vnr(S, VNR.advance(vnr));
  };

  //-----------------------------------------------------------------------------------------------------------
  this.row_from_vnr = (S, vnr) => {
    var dbr, vnr_txt;
    dbr = S.mirage.dbr;
    vnr_txt = jr(vnr);
    return dbr.$.first_row(dbr.datom_from_vnr({vnr_txt}));
  };

  //-----------------------------------------------------------------------------------------------------------
  this.datom_from_vnr = (S, vnr) => {
    var row;
    if ((row = this.row_from_vnr(S, vnr)) == null) {
      return null;
    }
    return this.datom_from_row(S, row);
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.register_key = (S, key, settings) => {
    /* TAINT use API for value conversions */
    var db, error, is_block;
    validate.datamill_register_key_settings;
    db = S.mirage.dbw;
    is_block = settings.is_block ? 1 : 0;
    try {
      db.register_key({key, is_block});
    } catch (error1) {
      error = error1;
      if (!error.message.startsWith("UNIQUE constraint failed")) {
        throw error;
      }
      throw new Error(`µ77754 key ${rpr(key)} already registered`);
    }
    this._key_registry_cache = null;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.register_or_validate_key = (S, key, settings) => {
    var db, definition, entry;
    validate.datamill_register_key_settings;
    db = S.mirage.dbw;
    if ((entry = db.$.first_row(db.get_key_entry({key}))) == null) {
      return this.register_key(S, key, settings);
    }
    definition = {
      key,
      is_block: settings.is_block
    };
    /* TAINT use API for value conversions */
    entry.is_block = entry.is_block === 1 ? true : false;
    if (!CND.equals(definition, entry)) {
      throw new Error(`µ87332 given key definition ${jr(definition)} doesn't match esisting entry ${rpr(entry)}`);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._key_registry_cache = null;

  //-----------------------------------------------------------------------------------------------------------
  this.get_key_registry = (S) => {
    var R, db, ref, row;
    if (this._key_registry_cache != null) {
      return this._key_registry_cache;
    }
    db = S.mirage.dbw;
    R = {};
    ref = db.read_key_registry();
    for (row of ref) {
      R[row.key] = row;
    }
    this._key_registry_cache = PD.freeze(R);
    return R;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.datom_from_row = (S, row) => {
    var $vnr, R, k, p, ref, vnr_txt;
    /* TAINT how to convert vnr in ICQL? */
    // debug 'µ22373', rpr row
    // debug 'µ22373', rpr row.vnr_txt
    // debug 'µ22373', rpr row.p
    vnr_txt = row.vnr_txt;
    $vnr = JSON.parse(vnr_txt);
    p = row.p != null ? JSON.parse(row.p) : {};
    R = PD.thaw(PD.new_datom(row.key, {$vnr}));
    R.dest = row.dest;
    if (row.text != null) {
      R.text = row.text;
    }
    if ((ref = row.stamped) != null ? ref : false) {
      R.$stamped = true;
    }
    for (k in p) {
      if (p[k] != null) {
        R[k] = p[k];
      }
    }
    return PD.freeze(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.p_from_datom = (S, d) => {
    var R, count, k, v;
    R = {};
    count = 0;
    for (k in d) {
      v = d[k];
      if (k === 'key') {
        continue;
      }
      if (k === 'text') {
        continue;
      }
      if (k === 'dest') {
        continue;
      }
      if (k.startsWith('$')) {
        continue;
      }
      if (v == null) {
        continue;
      }
      count += 1;
      R[k] = v;
    }
    if (count === 0) {
      R = null;
    }
    return JSON.stringify(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.row_from_datom = (S, d) => {
    /* TAINT how to convert booleans in ICQL? */
    var R, dest, key, p, ref, ref1, stamped, text, vnr_txt;
    key = d.key;
    stamped = (PD.is_stamped(d)) ? 1 : 0;
    vnr_txt = JSON.stringify(d.$vnr);
    dest = (ref = d.dest) != null ? ref : null;
    text = (ref1 = d.text) != null ? ref1 : null;
    p = this.p_from_datom(S, d);
    R = {key, vnr_txt, dest, text, p, stamped};
    // MIRAGE.types.validate.mirage_main_row R if do_validate
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.feed_source = (S, source, limit = 2e308) => {
    var dbr, nr, ref, row;
    dbr = S.mirage.db;
    nr = 0;
    ref = dbr.read_unstamped_lines();
    //.........................................................................................................
    for (row of ref) {
      nr += +1;
      if (nr > limit) {
        break;
      }
      source.send(this.datom_from_row(S, row));
    }
    //.........................................................................................................
    source.end();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$feed_db = (S) => {
    var dbw;
    dbw = S.mirage.dbw;
    return $watch((d) => {
      /* TAINT how to convert vnr in ICQL? */
      var changes, error, methods, row;
      row = this.row_from_datom(S, d);
      methods = [];
      try {
        /* TAINT consider to use upsert instead https://www.sqlite.org/lang_UPSERT.html */
        /* NOTE Make sure to test first for `$fresh`/inserts, then for `$dirty`/updates, since a `$fresh`
        datom may have undergone changes (which doesn't make the correct opertion an update). */
        if (d.$fresh) {
          methods.push('insert fresh');
          dbw.insert(row);
        } else if (d.$dirty) {
          /* NOTE force insert when update was without effect; this happens when `$vnr` was
          affected by a `PD.set()` call (ex. `VNR.advance $vnr; send PD.set d, '$vnr', $vnr`). */
          methods.push('update dirty');
          ({changes} = dbw.update(row));
          if (changes === 0) {
            methods.push('insert dirty');
            dbw.insert(row);
          }
        }
      } catch (error1) {
        error = error1;
        warn('µ12133', `when trying to ${methods.join(' -> ')} row`);
        warn('µ12133', jr(row));
        warn('µ12133', "an error occurred:");
        warn('µ12133', `${error.message}`);
        if (error.message.startsWith('UNIQUE constraint failed')) {
          urge('µ88768', "conflict occurred because");
          urge('µ88768', jr(this.row_from_vnr(S, d.$vnr)));
          urge('µ88768', "is already in DB");
        }
        throw error;
      }
      return null;
    });
  };

  //===========================================================================================================
  // PHASES
  //-----------------------------------------------------------------------------------------------------------
  this.repeat_phase = (S, phase) => {
    validate.datamill_phase_repeat(phase.repeat_phase);
    if (phase.repeat_phase == null) {
      return false;
    }
    if (isa.boolean(phase.repeat_phase)) {
      return phase.repeat_phase;
    }
    return phase.repeat_phase(S);
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.$show = (S) => {
    return $watch((d) => {
      var color;
      if (d.$stamped) {
        color = CND.grey;
      } else {
        switch (d.key) {
          case '^word':
            color = CND.gold;
            break;
          default:
            color = CND.white;
        }
      }
      return info(color(jr(d)));
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_tty_width = (S) => {
    var R, execSync;
    if ((R = process.stdout.columns) != null) {
      return R;
    }
    ({execSync} = require('child_process'));
    return parseInt(execSync("tput cols", {
      encoding: 'utf-8'
    }), 10);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.show_overview = (S, settings) => {
    /* TAINT consider to convert row to datom before display */
    var _color, color, dbr, defaults, dent, dest, key, level, line, line_width, omit_count, p, ref, ref1, row, text, value, vnr;
    line_width = this.get_tty_width(S);
    dbr = S.mirage.db;
    level = 0;
    omit_count = 0;
    //.........................................................................................................
    defaults = {
      raw: false,
      hilite: '^blank'
    };
    settings = assign({}, defaults, settings);
    ref = dbr.read_lines();
    // { limit: 30, }
    //.........................................................................................................
    for (row of ref) {
      if (settings.raw) {
        info(this.format_object(row));
        continue;
      }
      // if ( row.key is '^line' ) and ( row.stamped ) and ( row.text is '' )
      //   omit_count += +1
      //   continue
      // if ( row.stamped )
      //   omit_count += +1
      //   continue
      switch (row.key) {
        case '^line':
          _color = CND.YELLOW;
          break;
        case '^block':
          _color = CND.gold;
          break;
        case '^mktscript':
          _color = CND.RED;
          break;
        case '~warning':
          _color = CND.RED;
          break;
        case '~notice':
          _color = CND.cyan;
          break;
        case '^literal':
          _color = CND.GREEN;
          break;
        case '^literal-blank':
          _color = CND.GREEN;
          break;
        case '^p':
          _color = CND.BLUE;
          break;
        case '<h':
          _color = CND.VIOLET;
          break;
        case '>h':
          _color = CND.VIOLET;
          break;
        default:
          _color = this.color_from_text(row.key.slice(1));
      }
      //.......................................................................................................
      if (false && (row.key === '^blank')) {
        key = to_width('', 12);
        vnr = to_width('', 12);
        dest = to_width('', 8);
        text = '';
        p = '';
      } else {
        //.......................................................................................................
        key = to_width(row.key, 12);
        vnr = to_width(row.vnr_txt, 12);
        dest = to_width(row.dest, 8);
        text = row.text != null ? jr(row.text) : '';
        p = row.p != null ? row.p : '';
        if ((p == null) || (p === 'null')) {
          p = '';
        }
      }
      //.......................................................................................................
      value = text + ' ' + p;
      // value   = value[ .. 80 ]
      stamp = row.stamped ? 'S' : ' ';
      line = `${vnr} │ ${dest} │ ${stamp} │ ${key} │ ${value}`;
      line = to_width(line, line_width);
      dent = '  '.repeat(level);
      level = (function() {
        switch (row.key[0]) {
          case '<':
            return level + 1;
          case '>':
            return level - 1;
          default:
            return level;
        }
      })();
      level = Math.max(level, 0);
      //.......................................................................................................
      if ((settings.hilite != null) && (settings.hilite === row.key)) {
        color = function(...P) {
          return CND.reverse(CND.pink(...P));
        };
      } else if (row.stamped || row.key === '^blank') {
        color = CND.grey;
      } else {
        color = function(...P) {
          return CND.reverse(_color(...P));
        };
      }
      //.......................................................................................................
      echo(color(line));
    }
    // echo dent + color line
    //.........................................................................................................
    echo(`${omit_count} rows omitted from this view`);
    ref1 = dbr.get_stats();
    for (row of ref1) {
      echo(`${row.key}: ${row.count}`);
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  _color_cache = {};

  this.color_from_text = function(text) {
    var R;
    if ((R = _color_cache[text]) != null) {
      return R;
    }
    R = function(...P) {
      return (XXX_COLORIZER.ansi_code_from_text(text)) + CND._pen(...P);
    };
    // R = ( P... ) -> CND.reverse ( XXX_COLORIZER.ansi_code_from_text text ) + CND._pen P...
    _color_cache[text] = R;
    return R;
  };

}).call(this);

//# sourceMappingURL=helpers.js.map
