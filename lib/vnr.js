// Generated by CoffeeScript 2.5.1
(function() {
  'use strict';
  var CND, PD, assign, badge, debug, declare, echo, help, info, isa, jr, rpr, size_of, type_of, types, urge, validate, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'DATAMILL/HELPERS';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  ({jr, assign} = CND);

  PD = require('pipedreams');

  //...........................................................................................................
  types = require('./types');

  ({isa, validate, declare, size_of, type_of} = types);

  //-----------------------------------------------------------------------------------------------------------
  this.deepen = (d_or_vnr, nr = 0) => {
    var R;
    /* Given a vectorial line number `vnr`, return a copy of `vnr`, call it
     `vnr0`, which has an index of `0` appended, thus representing the pre-first `vnr` for a level of lines
     derived from the one that the original `vnr` pointed to. */
    if (!isa.list(d_or_vnr)) {
      return PD.set(d_or_vnr, '$vnr', this.deepen(d_or_vnr.$vnr));
    }
    validate.vnr(d_or_vnr);
    R = assign([], d_or_vnr);
    R.push(nr);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.advance = (d_or_vnr) => {
    return this._advance_or_recede(d_or_vnr, +1);
  };

  this.recede = (d_or_vnr) => {
    return this._advance_or_recede(d_or_vnr, -1);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._lower_bound = (vnr) => {
    /* Return a new VNR `z` such that `( as_hollerith vnr ) > ( as_hollerith z )` holds; this is needed to
     iterate over all rows within a given limit. */
    validate.vnr(vnr);
    return [vnr[0] - 1];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._upper_bound = (vnr) => {
    /* Return a new VNR `z` such that `( as_hollerith vnr ) < ( as_hollerith z )` holds; this is needed to
     iterate over all rows within a given limit. */
    validate.vnr(vnr);
    return [vnr[0] + 1];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._advance_or_recede = (d_or_vnr, delta) => {
    var R, idx;
    /* Given a vectorial line number `vnr`, return a copy of `vnr`, call it
     `vnr0`, which has its last index incremented by `1`, thus representing the vectorial line number of the
     next line in the same level that is derived from the same line as its predecessor. */
    if (!isa.list(d_or_vnr)) {
      return PD.set(d_or_vnr, '$vnr', this._advance_or_recede(d_or_vnr.$vnr));
    }
    validate.vnr(d_or_vnr);
    idx = d_or_vnr.length - 1;
    R = assign([], d_or_vnr);
    R[idx] += delta;
    return R;
  };

}).call(this);

//# sourceMappingURL=vnr.js.map
