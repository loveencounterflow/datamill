// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var $, $async, $watch, CND, H, MIRAGE, PD, VNR, assign, badge, cwd_abspath, cwd_relpath, debug, declare, echo, first, help, here_abspath, info, isa, jr, last, project_abspath, rpr, select, size_of, stamp, type_of, urge, validate, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'DATAMILL/MAIN';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  ({jr, assign} = CND);

  //...........................................................................................................
  require('./exception-handler');

  this.SF = require('./special-forms');

  first = Symbol('first');

  last = Symbol('last');

  MIRAGE = require('mkts-mirage');

  VNR = require('./vnr');

  //...........................................................................................................
  PD = require('pipedreams');

  ({$, $watch, $async, select, stamp} = PD);

  //...........................................................................................................
  this.types = require('./types');

  ({isa, validate, declare, size_of, type_of} = this.types);

  //...........................................................................................................
  H = require('./helpers');

  ({cwd_abspath, cwd_relpath, here_abspath, project_abspath} = H);

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT to be written; observe this will simplify `$blank_lines()`. */
  this.$trim = function(S) {
    return $((d, send) => {
      return send(d);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$blank_lines = function(S) {
    var flush, linecount, prv_vnr, send, within_blank;
    prv_vnr = null;
    linecount = 0;
    send = null;
    within_blank = false;
    // is_first      = true
    //.........................................................................................................
    flush = (n) => {
      var $vnr;
      within_blank = false;
      $vnr = VNR.new_level(prv_vnr);
      send(H.fresh_datom('^blank', {
        value: {linecount},
        $vnr
      }));
      return linecount = 0;
    };
    //.........................................................................................................
    return $({last}, (d, send_) => {
      send = send_;
      //.......................................................................................................
      if (d === last) {
        flush(); // if within_blank
        return null;
      }
      if (!select(d, '^mktscript')) {
        //.......................................................................................................
        return send(d);
      }
      //.......................................................................................................
      if (!isa.blank_text(d.value)) {
        if (within_blank) {
          flush();
        }
        prv_vnr = d.$vnr;
        return send(d);
      }
      //.......................................................................................................
      send(stamp(d));
      prv_vnr = d.$vnr;
      if (!within_blank) {
        linecount = 0;
      }
      linecount += +1;
      within_blank = true;
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$codeblocks = function(S) {
    /* Recognize codeblocks as regions delimited by triple backticks. Possible extensions include
    markup for source code category and double service as pre-formatted blocks. */
    var pattern, within_codeblock;
    pattern = /^(?<backticks>```)$/;
    within_codeblock = false;
    //.........................................................................................................
    return $((d, send) => {
      /* TAINT should somehow make sure properties are OK for a `^literal` */
      var $vnr, match;
      if (!select(d, '^mktscript')) {
        return send(d);
      }
      /* TAINT should send `<codeblock` datom */
      if ((match = d.value.match(pattern)) != null) {
        within_codeblock = !within_codeblock;
        send(stamp(d));
      } else {
        if (within_codeblock) {
          $vnr = VNR.new_level(d.$vnr, 1);
          d = PD.set(d, 'key', '^literal');
          d = PD.set(d, '$vnr', $vnr);
          d = PD.set(d, '$fresh', true);
        }
        send(d);
      }
      // $vnr  = VNR.new_level d.$vnr, 0
      // $vnr  = VNR.advance $vnr; send H.fresh_datom '<codeblock',        { level, $vnr, }
      // $vnr  = VNR.advance $vnr; send H.fresh_datom '>codeblock',        { level, $vnr, }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$heading = function(S) {
    /* Recognize heading as any line that starts with a `#` (hash). Current behavior is to
    check whether both prv and nxt lines are blank and if not so issue a warning; this detail may change
    in the future. */
    var pattern;
    pattern = /^(?<hashes>\#+)(?<text>.*)$/;
    //.........................................................................................................
    return $((d, send) => {
      var $vnr, level, match, message, nxt_line_is_blank, prv_line_is_blank, text;
      if (!select(d, '^mktscript')) {
        return send(d);
      }
      if ((match = d.value.match(pattern)) == null) {
        return send(d);
      }
      prv_line_is_blank = H.previous_line_is_blank(S, d.$vnr);
      nxt_line_is_blank = H.next_line_is_blank(S, d.$vnr);
      $vnr = VNR.new_level(d.$vnr, 0);
      if (!(prv_line_is_blank && nxt_line_is_blank)) {
        /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
        /* TAINT update PipeDreams: warnings always marked fresh */
        // warning = PD.new_warning d.$vnr, message, d, { $fresh: true, }
        message = "µ09082 heading should have blank lines above and below";
        $vnr = VNR.advance($vnr);
        send(H.fresh_datom('~warning', message, {$vnr}));
      }
      /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
      send(stamp(d));
      level = match.groups.hashes.length;
      text = match.groups.text.replace(/^\s*(.*?)\s*$/g, '$1');
      // debug 'µ88764', rpr match.groups.text
      // debug 'µ88764', rpr text
      /* TAINT use trim method */      $vnr = VNR.advance($vnr);
      send(H.fresh_datom('<h', {level, $vnr}));
      $vnr = VNR.advance($vnr);
      send(H.fresh_datom('^mktscript', text, {$vnr}));
      $vnr = VNR.advance($vnr);
      send(H.fresh_datom('>h', {level, $vnr}));
      return null;
    });
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.$phase_100 = function(S) {
    var pipeline;
    pipeline = [];
    pipeline.push(this.$trim(S));
    pipeline.push(this.$blank_lines(S));
    return PD.pull(...pipeline);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$phase_200 = function(S) {
    var pipeline;
    pipeline = [];
    pipeline.push(this.$codeblocks(S));
    pipeline.push(this.$heading(S));
    return PD.pull(...pipeline);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.run_phase = function(S, transform) {
    return new Promise((resolve, reject) => {
      var pipeline, source;
      source = PD.new_push_source();
      pipeline = [];
      pipeline.push(source);
      pipeline.push(transform);
      // pipeline.push H.$show S
      pipeline.push(H.$feed_db(S));
      pipeline.push(PD.$drain(() => {
        return resolve();
      }));
      PD.pull(...pipeline);
      return H.feed_source(S, source);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.translate_document = function(mirage) {
    return new Promise(async(resolve, reject) => {
      var S, i, len, limit, phase, phases, transform;
      S = {mirage};
      limit = 2e308;
      phases = ['$phase_100', '$phase_200'];
//.........................................................................................................
      for (i = 0, len = phases.length; i < len; i++) {
        phase = phases[i];
        transform = this[phase](S);
        help(`phase ${rpr(phase)}`);
        await this.run_phase(S, transform);
      }
      H.show_overview(S);
      resolve();
      //.........................................................................................................
      return null;
    });
  };

  //###########################################################################################################
  if (module.parent == null) {
    (async() => {
      var mirage, settings;
      //.......................................................................................................
      settings = {
        file_path: project_abspath('./src/tests/demo.md'),
        db_path: '/tmp/mirage.db',
        icql_path: project_abspath('./db/datamill.icql')
      };
      mirage = (await MIRAGE.create(settings));
      await this.translate_document(mirage);
      return help('ok');
    })();
  }

}).call(this);

//# sourceMappingURL=main.js.map
