// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var $, $async, $watch, CND, H, MIRAGE, PD, VNR, assign, badge, cwd_abspath, cwd_relpath, debug, declare, echo, first, first_of, help, here_abspath, info, isa, jr, last, last_of, project_abspath, rpr, select, size_of, stamp, type_of, urge, validate, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'DATAMILL/MAIN';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  ({jr, assign} = CND);

  //...........................................................................................................
  require('./exception-handler');

  first = Symbol('first');

  last = Symbol('last');

  MIRAGE = require('mkts-mirage');

  VNR = require('./vnr');

  //...........................................................................................................
  PD = require('pipedreams');

  ({$, $watch, $async, select, stamp} = PD);

  //...........................................................................................................
  this.types = require('./types');

  ({isa, validate, declare, first_of, last_of, size_of, type_of} = this.types);

  //...........................................................................................................
  H = require('./helpers');

  ({cwd_abspath, cwd_relpath, here_abspath, project_abspath} = H);

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.run_phase = function(S, transform) {
    return new Promise((resolve, reject) => {
      var $capture_control_messages, pipeline, source;
      //.........................................................................................................
      $capture_control_messages = function(S) {
        return $((d, send) => {
          if (select(d, '~')) {
            switch (d.key) {
              case '~datamill-break-phase-and-repeat':
                return S.control.push(d);
              default:
                throw new Error(`µ98401 unknown system key ${rpr(d.key)}`);
            }
          } else {
            return send(d);
          }
        });
      };
      //.........................................................................................................
      source = PD.new_push_source();
      pipeline = [];
      pipeline.push(source);
      // pipeline.push PD.mark_position $ ( pd, send ) =>
      //   { is_first
      //     is_last
      //     d       } = pd
      //   if @_is_reprising S
      //     urge 'µ11231', is_first, is_last, jr d
      //   send d
      pipeline.push(transform);
      pipeline.push($capture_control_messages(S));
      pipeline.push(H.$feed_db(S));
      pipeline.push(PD.$drain(() => {
        return resolve();
      }));
      PD.pull(...pipeline);
      return H.feed_source(S, source);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_datamill = function(mirage) {
    var R;
    R = {
      mirage: mirage,
      control: {
        active_phase: null,
        queue: [],
        /* A queue for flow control messages */reprise: {
          start_vnr: null,
          stop_vnr: null,
          phase: null
        }
      }
    };
/* name of phase that queued control messages */    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._set_active_phase = (S, phase_name) => {
    return S.control.active_phase = phase_name;
  };

  this._cancel_active_phase = (S) => {
    return S.control.active_phase = null;
  };

  this._length_of_control_queue = (S) => {
    return S.control.queue.length;
  };

  this._control_queue_has_messages = (S) => {
    return (this._length_of_control_queue(S)) > 0;
  };

  this._next_control_message_is_from = (S, phase_name) => {
    var ref;
    return ((ref = S.control.queue[0]) != null ? ref.phase : void 0) === phase_name;
  };

  this._is_reprising = (S) => {
    return S.control.reprise.phase != null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._set_to_reprising = (S, message) => {
    validate.datamill_reprising_message(message);
    assign(S.control.reprise.phase, message);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._pluck_next_control_message = (S) => {
    var message;
    if (!(S.control.queue.length > 0)) {
      throw new Error("µ11092 queue is empty");
    }
    message = S.control.queue.shift();
    assign(S.control.reprise, message);
    return message;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.reprise = (S, region) => {
    var first_vnr, last_vnr;
    validate.datamill_inclusive_region(region);
    validate.nonempty_text(S.control.active_phase);
    ({first_vnr, last_vnr} = region);
    S.control.queue.push(PD.new_datom('~reprise', {
      first_vnr,
      last_vnr,
      phase: S.control.active_phase
    }));
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.translate_document = function(mirage) {
    return new Promise(async(resolve, reject) => {
      var S, i, len, limit, message, pass, phase, phase_name, phase_names;
      S = this.new_datamill(mirage);
      limit = 2e308;
      phase_names = ['./000-initialize', './005-start-stop', './006-ignore', './010-whitespace-1', './020-blocks', './025-whitespace-2'];
      while (true) {
        try {
        // ### TAINT use API ###
        // S.confine_to = null
        // S.confine_from_phase = null
        //.........................................................................................................
        // './030-1-paragraphs-breaks'
        // './030-2-paragraphs-consolidate'
        // './040-markdown-inline'
        // # './030-escapes'
        // # './035-special-forms'
        // './xxx-validation'
          for (i = 0, len = phase_names.length; i < len; i++) {
            phase_name = phase_names[i];
            this._set_active_phase(S, phase_name);
            // length_of_queue = @_length_of_control_queue S
            phase = require(phase_name);
            pass = 1;
            help('µ55567 ' + (CND.reverse(CND.yellow(` pass ${pass} `))) + (CND.lime(` phase ${phase_name} `)));
            await this.run_phase(S, phase.$transform(S));
            //.....................................................................................................
            /* TAINT use proper flag / API */
            // for x in S.control.queue
            //   debug 'µ09087', jr x
            // if length_of_queue isnt @_length_of_control_queue S
            if (this._next_control_message_is_from(S, phase_name)) {
              this._cancel_active_phase(S);
              throw this._pluck_next_control_message(S);
            }
            //.....................................................................................................
            if (H.repeat_phase(S, phase)) {
              throw new Error(`µ33443 phase repeating not implemented (${rpr(phase_name)})`);
            }
            this._cancel_active_phase(S);
          }
        } catch (error) {
          //.........................................................................................................
          message = error;
          if (!(select(message, '~reprise'))) {
            throw message;
          }
          info(`µ33324 reprising, confined to ${jr(message.first_vnr)} <= vnr <= ${jr(message.last_vnr)}`);
          /* TAINT use API */
          this._set_to_reprising(S, message);
          continue;
        }
        break;
      }
      //.........................................................................................................
      // H.show_overview S, { hilite: '^blank', }
      H.show_overview(S);
      resolve();
      //.........................................................................................................
      return null;
    });
  };

  //###########################################################################################################
  if (module.parent == null) {
    (async() => {
      var db, first_vnr_blob, last_vnr_blob, mirage, ref, row, settings;
      //.......................................................................................................
      settings = {
        file_path: project_abspath('./src/tests/demo.md'),
        // file_path:    project_abspath './src/tests/demo-simple-paragraphs.md'
        // db_path:      ':memory:'
        db_path: project_abspath('./db/datamill.db'),
        icql_path: project_abspath('./db/datamill.icql'),
        default_key: '^line',
        default_dest: 'main',
        clear: true
      };
      help(`using database at ${settings.db_path}`);
      mirage = (await MIRAGE.create(settings));
      await this.translate_document(mirage);
      //.......................................................................................................
      db = mirage.db;
      first_vnr_blob = db.$.as_hollerith([42, 0]);
      last_vnr_blob = db.$.as_hollerith([42, 0]);
      ref = db.read_unstamped_lines({first_vnr_blob, last_vnr_blob});
      for (row of ref) {
        info(jr(H.datom_from_row(null, row)));
      }
      // { prv_dest, dest, stamped, key, } = row
      // info jr { prv_dest, dest, stamped, key, }
      //.......................................................................................................
      // for row from db.$.query "select * from dest_changes_forward order by vnr_blob;"
      //   { prv_dest, dest, stamped, key, } = row
      //   info jr { prv_dest, dest, stamped, key, }
      // for row from db.read_changed_dest_last_lines()
      //   delete row.vnr_blob
      //   help jr row
      // for row from db.read_changed_dest_first_lines()
      //   delete row.vnr_blob
      //   info jr row
      // help 'ok'
      return null;
    })();
  }

}).call(this);

//# sourceMappingURL=main.js.map
